"""Alert rules engine for monitoring trading system health."""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Any, Optional, Callable
from abc import ABC, abstractmethod

from .events import TradingEvent, EventTypes


@dataclass
class Alert:
    """An alert generated by a rule."""
    rule_name: str
    severity: str  # warning, critical
    title: str
    message: str
    triggered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "rule_name": self.rule_name,
            "severity": self.severity,
            "title": self.title,
            "message": self.message,
            "triggered_at": self.triggered_at.isoformat(),
            "metadata": self.metadata,
        }


class AlertRule(ABC):
    """Abstract base class for alert rules."""

    name: str
    severity: str = "warning"
    cooldown_minutes: int = 60  # Don't re-trigger for this many minutes

    def __init__(self):
        self.last_triggered: Optional[datetime] = None

    @abstractmethod
    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        """
        Check if the rule should trigger.

        Args:
            context: Dictionary with performance data, positions, etc.

        Returns:
            Alert if triggered, None otherwise
        """
        pass

    def can_trigger(self) -> bool:
        """Check if cooldown has passed."""
        if self.last_triggered is None:
            return True
        cooldown = timedelta(minutes=self.cooldown_minutes)
        return datetime.now(timezone.utc) - self.last_triggered > cooldown

    def mark_triggered(self):
        """Mark this rule as triggered."""
        self.last_triggered = datetime.now(timezone.utc)


class MaxDrawdownRule(AlertRule):
    """Alert when drawdown exceeds threshold."""

    name = "max_drawdown"
    severity = "critical"
    cooldown_minutes = 30

    def __init__(self, threshold_pct: float = 10.0):
        super().__init__()
        self.threshold_pct = threshold_pct

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        drawdown = context.get("current_drawdown_pct", 0)
        if drawdown >= self.threshold_pct:
            self.mark_triggered()
            return Alert(
                rule_name=self.name,
                severity=self.severity,
                title="Maximum Drawdown Alert",
                message=f"Current drawdown {drawdown:.2f}% exceeds threshold {self.threshold_pct:.2f}%",
                metadata={"drawdown_pct": drawdown, "threshold_pct": self.threshold_pct},
            )
        return None


class DailyLossRule(AlertRule):
    """Alert when daily loss exceeds limit."""

    name = "daily_loss"
    severity = "critical"
    cooldown_minutes = 60

    def __init__(self, limit_pct: float = 5.0):
        super().__init__()
        self.limit_pct = limit_pct

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        daily_pnl_pct = context.get("daily_pnl_pct", 0)
        if daily_pnl_pct <= -self.limit_pct:
            self.mark_triggered()
            return Alert(
                rule_name=self.name,
                severity=self.severity,
                title="Daily Loss Limit Breached",
                message=f"Daily PnL {daily_pnl_pct:.2f}% exceeds loss limit -{self.limit_pct:.2f}%",
                metadata={"daily_pnl_pct": daily_pnl_pct, "limit_pct": self.limit_pct},
            )
        return None


class RiskBreachRule(AlertRule):
    """Alert when too many risk breaches occur."""

    name = "risk_breach_count"
    severity = "warning"
    cooldown_minutes = 120

    def __init__(self, threshold: int = 3, window_hours: int = 24):
        super().__init__()
        self.threshold = threshold
        self.window_hours = window_hours

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        breach_count = context.get("risk_breach_count_24h", 0)
        if breach_count >= self.threshold:
            self.mark_triggered()
            return Alert(
                rule_name=self.name,
                severity=self.severity,
                title="Multiple Risk Breaches",
                message=f"{breach_count} risk breaches in last {self.window_hours}h (threshold: {self.threshold})",
                metadata={"breach_count": breach_count, "threshold": self.threshold},
            )
        return None


class LowSharpeRule(AlertRule):
    """Alert when rolling Sharpe ratio is negative."""

    name = "low_sharpe"
    severity = "warning"
    cooldown_minutes = 240  # 4 hours

    def __init__(self, threshold: float = 0.0, lookback_days: int = 30):
        super().__init__()
        self.threshold = threshold
        self.lookback_days = lookback_days

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        sharpe = context.get("rolling_sharpe", None)
        if sharpe is not None and sharpe < self.threshold:
            self.mark_triggered()
            return Alert(
                rule_name=self.name,
                severity=self.severity,
                title="Low Sharpe Ratio Warning",
                message=f"Rolling {self.lookback_days}-day Sharpe ratio is {sharpe:.2f} (threshold: {self.threshold})",
                metadata={"sharpe": sharpe, "threshold": self.threshold},
            )
        return None


class PositionConcentrationRule(AlertRule):
    """Alert when a single position is too large."""

    name = "position_concentration"
    severity = "warning"
    cooldown_minutes = 60

    def __init__(self, max_concentration_pct: float = 50.0):
        super().__init__()
        self.max_concentration_pct = max_concentration_pct

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        positions = context.get("positions", {})
        total_value = sum(abs(p.get("value_usd", 0)) for p in positions.values())

        if total_value == 0:
            return None

        for symbol, pos in positions.items():
            concentration = abs(pos.get("value_usd", 0)) / total_value * 100
            if concentration > self.max_concentration_pct:
                self.mark_triggered()
                return Alert(
                    rule_name=self.name,
                    severity=self.severity,
                    title="Position Concentration Warning",
                    message=f"{symbol} is {concentration:.1f}% of portfolio (max: {self.max_concentration_pct}%)",
                    metadata={"symbol": symbol, "concentration_pct": concentration},
                )
        return None


class ConsecutiveLossRule(AlertRule):
    """Alert on consecutive losing trades."""

    name = "consecutive_losses"
    severity = "warning"
    cooldown_minutes = 180

    def __init__(self, threshold: int = 5):
        super().__init__()
        self.threshold = threshold

    def check(self, context: Dict[str, Any]) -> Optional[Alert]:
        if not self.can_trigger():
            return None

        consecutive_losses = context.get("consecutive_losses", 0)
        if consecutive_losses >= self.threshold:
            self.mark_triggered()
            return Alert(
                rule_name=self.name,
                severity=self.severity,
                title="Consecutive Losses Warning",
                message=f"{consecutive_losses} consecutive losing trades (threshold: {self.threshold})",
                metadata={"consecutive_losses": consecutive_losses},
            )
        return None


class AlertManager:
    """
    Manages alert rules and checks them against current state.
    """

    def __init__(self):
        self.rules: List[AlertRule] = []
        self.alert_history: List[Alert] = []
        self.max_history = 1000

    def add_rule(self, rule: AlertRule) -> None:
        """Add an alert rule."""
        self.rules.append(rule)

    def remove_rule(self, rule_name: str) -> bool:
        """Remove a rule by name."""
        for i, rule in enumerate(self.rules):
            if rule.name == rule_name:
                self.rules.pop(i)
                return True
        return False

    def add_default_rules(
        self,
        max_drawdown_pct: float = 10.0,
        daily_loss_limit_pct: float = 5.0,
        risk_breach_threshold: int = 3,
    ) -> None:
        """Add default set of alert rules."""
        self.add_rule(MaxDrawdownRule(max_drawdown_pct))
        self.add_rule(DailyLossRule(daily_loss_limit_pct))
        self.add_rule(RiskBreachRule(risk_breach_threshold))
        self.add_rule(LowSharpeRule())
        self.add_rule(PositionConcentrationRule())
        self.add_rule(ConsecutiveLossRule())

    def check_all(self, context: Dict[str, Any]) -> List[Alert]:
        """
        Check all rules against current context.

        Args:
            context: Dictionary with performance data

        Returns:
            List of triggered alerts
        """
        triggered = []
        for rule in self.rules:
            try:
                alert = rule.check(context)
                if alert:
                    triggered.append(alert)
                    self.alert_history.append(alert)
            except Exception as e:
                print(f"[AlertManager] Error checking rule {rule.name}: {e}")

        # Trim history
        if len(self.alert_history) > self.max_history:
            self.alert_history = self.alert_history[-self.max_history:]

        return triggered

    def check_event(self, event: TradingEvent) -> List[Alert]:
        """
        Check rules in response to an event.

        Builds context from event and checks all rules.
        """
        context = {
            "event_type": event.event_type,
            "severity": event.severity,
            **event.payload,
        }
        return self.check_all(context)

    def get_recent_alerts(
        self,
        hours: int = 24,
        severity: Optional[str] = None,
    ) -> List[Alert]:
        """Get recent alerts with optional filtering."""
        cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)
        alerts = [a for a in self.alert_history if a.triggered_at >= cutoff]

        if severity:
            alerts = [a for a in alerts if a.severity == severity]

        return alerts
